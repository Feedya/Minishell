#include "../../head.h"

int count_big_taille_of_argc_command(t_line *node)
{
  int taille;
  int i;

  i = 0;
  taille = 0;
	if (node->commande != NULL)
		taille++;
  if (node->flag != NULL)
  {
		taille++;
    while (node->flag[i] != '\0')
    {
      if (node->flag[i] == ' ')
			{
				while (node->flag[i] == ' ')
					i++;
				taille++;
			}
			else
				i++;
    }
  }
	node = node->next;
  while (node != NULL)
	{
		if (node->type == TOKEN_PIPE || node->type == TOKEN_APPEND || node->type == TOKEN_HEREDOC || node->type == TOKEN_REDIRECT_IN || node->type == TOKEN_REDIRECT_OUT)
			break;
		node = node->next;
		taille++;
	}
	printf("big taille\n");
	return (taille);
}

int	malloc_flag_part_command_argc(char **argc, int *index, char *flag)
{
	int	i;
	int c;
	int	taille;

	taille = 0;
	c = *index;
	i = 0;
	while (flag[i] != '\0')
	{
		if (flag[i] == ' ')
		{
			argc[c] = malloc(sizeof(char) * (taille + 1));
			if (argc[c] == NULL)
				return (-1);
			c++;
			while (flag[i] == ' ')
				i++;
			taille = 0;
		}
		else
		{
			i++;
			taille++;
		}
	}
	if (taille > 0)
	{
		argc[c] = malloc(sizeof(char) * (taille + 1));
		if (argc[c] == NULL)
			return (1);
		c++;
	}
	*index = c;
	return (0);
}

int	malloc_valeur_part_command_argc(t_line *node, char **argc, int *index)
{
	int	taille;
	int	c;

	c = *index;
	taille = 0;
	if (node->next != NULL)
		node = node->next;
	while (node != NULL)
	{
		if (node->type == TOKEN_APPEND || node->type == TOKEN_HEREDOC || node->type == TOKEN_PIPE || node->type == TOKEN_REDIRECT_IN || node->type == TOKEN_REDIRECT_OUT)
			break ;
		while (node->valeur[taille] != '\0')
			taille++;
		argc[c] = malloc(sizeof(char) * (taille + 1));
		if (argc[c] == NULL)
			return (1);
		c++;
		taille = 0;
		node = node->next;
	}
	argc[c] = NULL;
	return (0);
}


//Cette fonction doit prendre les flags et les valeur des prochains noeuds et mettre dans un char **argc pour pouvoir faire execve
/*int malloc_small_parts_command_argc(char **argc, t_line *node, char *flag)
{
	int taille;
	int	c;
	int	error;

	taille = 0;
	c = 0;
	error = 0;
	//on malloc le premier char * de la commande
	while (node->commande[taille] != '\0')
		taille++;
	argc[c] = malloc(sizeof(char) * (taille + 1));
	if (argc[c] == NULL)
		return (1);
	c++;

	//on malloc le flag
	if (flag != NULL)
	{
		error = malloc_flag_part_command_argc(argc, &c, flag);
	}
	if (error == 1)//si malloc dans malloc_valeur_part_commande_argc n a pas fonctionnerr
	{
		printf("deuxieme if\n");
		return (1);
	}
	//verification si on a qun un seul noeud
	if (node->next == NULL)
	{
		printf("troisieme if\n");
		return (0);
	}
	//on malloc dans argc pour les valeur des prochain noeuds
	if (malloc_valeur_part_command_argc(node, argc, &c) == 1)
	{
		return (1);
	}
	if (node->argc == NULL)
		printf("argc est null\n");
	return (0);
}*/

int	malloc_commande_argc(char **argc, t_line *node, int *big_taille_index)
{
	int	index;
	int	i;

	i = 0;
	index = *big_taille_index;
	if (node->command_type == TOKEN_COMMANDE)
	{
		while (node->valeur[i] != '\0')
			i++;
		argc[index] = malloc(sizeof(char) * (i + 1));
		if (argc[index] == NULL)
			return (1);
		index++;
		*big_taille_index = index;
		return (0);
	}
	printf("commande dans create_argc_of_command.c dans la fonction malloc_commande_argc\n");
	printf("normalement cette erreur ne devrait jamais arriver\n");
	printf("c est parceque le noeud n est pas une commande\n");
	return (1);
}

int malloc_small_parts_command_argc(char **argc, t_line *node, char *flag, int big_taille)
{
	int	error;
	int	index;

	index = 0;
	error = 0;
	if (malloc_commande_argc(argc, node, &index) == 1)
		return (1);
	if (node->flag != NULL)
		error = malloc_flag_argc(node, argc);
	
	/*
	if (error == 1)
		return (0);
	*/
}

int malloc_argc_of_node(t_line *node)
{
  int big_taille;
  int erreur;
	int	i;

	i = 0;
  erreur = 0;
  big_taille = count_big_taille_of_argc_command(node);
	if (big_taille == 0)
	{
		node->argc = NULL;
		return (0);
	}
	printf("BIG TAILLE : %d\n", big_taille);
  node->argc = malloc((sizeof(char *)) * (big_taille + 1));
  if (node->argc == NULL)
    return (1);
	while (i <= big_taille)
	{
		node->argc[i] = NULL;
		i++;
	}
  erreur = malloc_small_parts_command_argc(node->argc, node, node->flag, big_taille);
  if (erreur == 1)
    return (1);
  return (0);
}

int create_argc(t_line *node)
{
  int erreur;

  erreur = malloc_argc_of_node(node);//on va mallocer le char **argc dans notre noeud commande
	if (node->argc == NULL)
	{
		printf("dans create argc si argc est egale a NULL\n");
		return (0);
	}
  if (erreur == 1)
    return (1);
	erreur = remplir_argc_of_command_node(node);//on va remplir l espace qu on a malloc char **argc
	return (0);
}



//DEUXIEME FICHIERRRRRRRRR


#include "../../head.h"

int	remplir_argc_node_command_flag(char **argc, char *flag)
{
	int	i;
	int	c;
	int	d;

	i = 0;
	c = 1;
	d = 0;
	while(flag[i] != '\0')
	{
		if (flag[i] == ' ')
		{
			argc[c][d] = '\0';
			while (flag[i] == ' ')
				i++;
			c++;
			d = 0;
		}
		else
		{
			argc[c][d] = flag[i];
			i++;
			d++;
		}
	}
	argc[c][d] = '\0';
	return (c);
}

void remplir_argc_node_command_valeur(char **argc, t_line *node, int taille)
{
	int	i;
	int	d;

	i = 0;
	d = 0;
	if (taille == 0)
		taille = 0;
	else
		taille++;//parceque la taille indexe le dernier qu on a remplis
	while (node != NULL && node->type != TOKEN_PIPE && node->type != TOKEN_APPEND && node->type != TOKEN_HEREDOC && node->type != TOKEN_REDIRECT_IN && node->type != TOKEN_REDIRECT_OUT)
	{
		while (node->valeur[i] != '\0')
		{
			argc[taille][d] = node->valeur[i];
			i++;
			d++;
		}
		argc[taille][d] = '\0';
		taille++;
		d = 0;
		i = 0;
		node = node->next;
	}
	argc[taille] = NULL;
}

int remplir_argc_of_command_node(t_line *node)
{
  int taille;

	taille = 0;
	while (node->commande[taille] != '\0')
	{
		node->argc[0][taille] = node->commande[taille];
		taille++;
	}
	taille = 1;
	if (node->flag == NULL && node->next == NULL)
	{
		node->next = NULL;
		node->prev = NULL;
		return (0);
	}
	printf("avant le if");
  if (node->flag != NULL)
    taille = remplir_argc_node_command_flag(node->argc, node->flag);
	printf("taille apres avoir mis les flags");
	remplir_argc_node_command_valeur(node->argc, node->next, taille);
	return (0);
}



FONCTION POUR PUT ENV variables
char	*take_env_from_node(char *str, int index)
{
	int	taille;
	int	temp_index;
	char *dest;

	temp_index = index + 1;
	taille = 0;
	index++;
	while (str[index] != '\0' && str[index] != ' ' && str[index] != '"' && str[index] != '\'' && str[index] != '$')
	{
		index++;
		taille++;
	}
	dest = malloc(sizeof(char) * (taille + 2));
	if (dest == NULL)
		return (NULL);
	dest[0] = '$';
	taille = 1;
	index = temp_index;
	while (str[index] != '\0' && str[index] != ' ' && str[index] != '"' && str[index] != '\'' && str[index] != '$')
	{
		dest[taille] = str[index];
		index++;
		taille++;
	}
	dest[taille] = '\0';
	return (dest);
}

int	verification_if_env_exist(char *env, char **path, int *index)
{
	int	i;
	int	c;
	int	d;

	d = 1;
	i = 0;
	c = 0;
	while (path[i] != NULL)
	{
		d = 1;
		c = 0;
		while (path[i][c] == env[d])
		{
			c++;
			d++;
		}
		if (path[i][c] == '=' && env[d] == '\0')
		{
			*index = i;
			return (0);
		}
		i++;
	}
	*index == -1;
	return (1);
}

int	make_env_var(t_line *node, char *str, int index, t_all *all)
{
	char *env;
	int	existe;
	int	error;
	int	index;

	error = 0;
	existe = 0;
	env = take_env_from_node(str, index);
	if (env == NULL)
		return (1);
	(void)all;
	(void)node;
	existe = verification_if_env_exist(env, all->env, &index);
	if (existe == 1)//la variables d env existe
	{
		error = if_exist_fill(node, env, all->env_values[index]);
		if (error == 1)
			return (1);
	}
	else //la variable d env n existe pas
	(void)existe;
	free(env);
	return (0);
}



int	count_taille_of_env(char *str, int index, char **all_env, t_all *all)
{
	char *env;
	int	taille;

	taille = 0;
	env = take_env_from_node(str, index);

}

int	count_taille_of_full_env(char *str, char **all_env, t_all *all)
{
	int	taille;
	int	index;

	index = 0;
	taille = 0;
	while (str[index] != '\0')
	{
		if (str[i] == '$' && str[i + 1] != '\0' && str[i + 1] != ' ' && str[i + 1] != '$')
			taille = taille + count_taille_of_env(str, index, all_env, all);
		else
		{
			taille++;
			index++;
		}
	}
}

int env_variables(t_line *node, t_all *all, char *str)
{
  int i;
  int error;
	int	counter;
	int	taille;

	counter = 0;
  error = 0;
  i = 0;
  while (str[i] != '\0')
  {
    if (str[i] == '$' && str[i + 1] != '\0' && str[i + 1] != ' ' && str[i + 1] != '$')
			counter++;
    i++;
  }
	taille = count_taille_of_full_env(str, all, ta);
  return (0);
}